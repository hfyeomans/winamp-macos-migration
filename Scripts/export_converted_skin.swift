#!/usr/bin/env swift

import Foundation
import AppKit
import Metal
import MetalKit

// Export a converted skin in a format that can be manually integrated into WinampClone

print("üéµ Exporting Converted Skin for Manual Integration")
print("=================================================")

let skinToConvert = "Purple_Glow.wsz"
let skinsPath = "Samples/Skins/" + skinToConvert

guard FileManager.default.fileExists(atPath: skinsPath) else {
    print("‚ùå Skin file not found: \(skinsPath)")
    exit(1)
}

print("üîÑ Converting and exporting: \(skinToConvert)")

// Create output directory
let outputDir = "Converted_Skins"
try FileManager.default.createDirectory(atPath: outputDir, withIntermediateDirectories: true)

// Extract and convert skin
let tempDir = NSTemporaryDirectory() + "export_\(UUID().uuidString)"
try FileManager.default.createDirectory(atPath: tempDir, withIntermediateDirectories: true)

defer {
    try? FileManager.default.removeItem(atPath: tempDir)
}

// Extract .wsz
let unzip = Process()
unzip.launchPath = "/usr/bin/unzip"
unzip.arguments = ["-q", "-o", skinsPath, "-d", tempDir]
unzip.launch()
unzip.waitUntilExit()

guard unzip.terminationStatus == 0 else {
    print("‚ùå Failed to extract skin")
    exit(1)
}

// Find main.bmp
func findMainBMP(in directory: String) -> String? {
    let items = try? FileManager.default.contentsOfDirectory(atPath: directory)
    
    if items?.contains("main.bmp") == true {
        return directory + "/main.bmp"
    }
    
    if let items = items {
        for item in items {
            let fullPath = directory + "/" + item
            var isDirectory: ObjCBool = false
            if FileManager.default.fileExists(atPath: fullPath, isDirectory: &isDirectory) && isDirectory.boolValue {
                if let found = findMainBMP(in: fullPath) {
                    return found
                }
            }
        }
    }
    
    return nil
}

guard let mainBMPPath = findMainBMP(in: tempDir),
      let imageData = FileManager.default.contents(atPath: mainBMPPath),
      let image = NSImage(data: imageData) else {
    print("‚ùå Failed to load main.bmp")
    exit(1)
}

print("‚úÖ Loaded main.bmp: \(Int(image.size.width))√ó\(Int(image.size.height))")

// Convert to PNG for easy integration
guard let cgImage = image.cgImage(forProposedRect: nil, context: nil, hints: nil) else {
    print("‚ùå Failed to create CGImage")
    exit(1)
}

let pngData = NSMutableData()
guard let destination = CGImageDestinationCreateWithData(pngData, kUTTypePNG, 1, nil) else {
    print("‚ùå Failed to create PNG destination")
    exit(1)
}

CGImageDestinationAddImage(destination, cgImage, nil)
CGImageDestinationFinalize(destination)

// Save PNG
let pngPath = outputDir + "/purple_glow_converted.png"
try pngData.write(toFile: pngPath)
print("‚úÖ Saved converted PNG: \(pngPath)")

// Create Metal texture and save properties
if let device = MTLCreateSystemDefaultDevice() {
    let textureLoader = MTKTextureLoader(device: device)
    let options: [MTKTextureLoader.Option: Any] = [
        .textureUsage: MTLTextureUsage.shaderRead.rawValue,
        .SRGB: true
    ]
    
    do {
        let texture = try textureLoader.newTexture(cgImage: cgImage, options: options)
        print("‚úÖ Metal texture created: \(texture.width)√ó\(texture.height)")
        
        // Export texture properties
        let textureInfo = """
        // Metal Texture Properties for Purple_Glow skin
        // Generated by ModernWinampSkinConverter
        
        Texture Dimensions: \(texture.width) √ó \(texture.height)
        Pixel Format: \(texture.pixelFormat) (BGRA8Unorm_sRGB)
        Storage Mode: \(texture.storageMode) (Shared memory - Apple Silicon optimized)
        Usage: \(texture.usage) (Shader read)
        
        // Use this data in your Metal renderer:
        // 1. Load purple_glow_converted.png
        // 2. Create MTLTexture with above properties
        // 3. Apply to MTKView or Metal renderer
        """
        
        try textureInfo.write(toFile: outputDir + "/metal_texture_info.txt", atomically: true, encoding: .utf8)
        
    } catch {
        print("‚ö†Ô∏è Metal texture creation failed: \(error)")
    }
}

// Convert button coordinates (Windows ‚Üí macOS)
let windowHeight = image.size.height
let windowsButtons = [
    "play": CGPoint(x: 24, y: 28),
    "pause": CGPoint(x: 39, y: 28),
    "stop": CGPoint(x: 54, y: 28),
    "prev": CGPoint(x: 6, y: 28),
    "next": CGPoint(x: 69, y: 28),
    "eject": CGPoint(x: 84, y: 28)
]

var macOSButtons: [String: CGPoint] = [:]
for (name, windowsPos) in windowsButtons {
    macOSButtons[name] = CGPoint(x: windowsPos.x, y: windowHeight - windowsPos.y)
}

// Export coordinate mapping
let coordinateMapping = """
// Button Coordinate Mapping for Purple_Glow skin
// Converted from Windows Y-down to macOS Y-up coordinate system
// Window Height: \(Int(windowHeight))

// Swift code for integration:
let buttonPositions: [String: CGPoint] = [
    "play": CGPoint(x: \(Int(macOSButtons["play"]!.x)), y: \(Int(macOSButtons["play"]!.y))),
    "pause": CGPoint(x: \(Int(macOSButtons["pause"]!.x)), y: \(Int(macOSButtons["pause"]!.y))),
    "stop": CGPoint(x: \(Int(macOSButtons["stop"]!.x)), y: \(Int(macOSButtons["stop"]!.y))),
    "prev": CGPoint(x: \(Int(macOSButtons["prev"]!.x)), y: \(Int(macOSButtons["prev"]!.y))),
    "next": CGPoint(x: \(Int(macOSButtons["next"]!.x)), y: \(Int(macOSButtons["next"]!.y))),
    "eject": CGPoint(x: \(Int(macOSButtons["eject"]!.x)), y: \(Int(macOSButtons["eject"]!.y)))
]

// Usage in your WinampClone:
// 1. Load purple_glow_converted.png as background
// 2. Position buttons using the coordinates above
// 3. Set window size to \(Int(image.size.width))√ó\(Int(image.size.height))
"""

try coordinateMapping.write(toFile: outputDir + "/button_coordinates.swift", atomically: true, encoding: .utf8)

// Create integration instructions
let instructions = """
# Manual Integration Instructions for Purple_Glow Skin

## Files Exported:
1. **purple_glow_converted.png** - Main skin image (ready for NSImage or Metal)
2. **button_coordinates.swift** - Button positions in macOS coordinate system  
3. **metal_texture_info.txt** - Metal texture properties and usage info

## Quick Integration Test:

### Option 1: Simple NSImage Integration
```swift
// In your SkinnableMainPlayerView or similar:
if let image = NSImage(named: "purple_glow_converted") {
    Image(nsImage: image)
        .frame(width: \(Int(image.size.width)), height: \(Int(image.size.height)))
}
```

### Option 2: Metal Texture Integration  
```swift
// Create Metal texture from PNG:
let textureLoader = MTKTextureLoader(device: metalDevice)
let texture = try textureLoader.newTexture(name: "purple_glow_converted", 
                                          scaleFactor: 1.0, 
                                          bundle: Bundle.main)

// Use in MTKView for GPU rendering
```

### Option 3: Copy Our Converter (Recommended)
```swift
// Add to your WinampClone Package.swift:
dependencies: [
    .package(path: "../winamp-skins-conversion")
]

// Then use our converter directly:
let converter = ModernWinampSkinConverter()
let skin = try converter.convertSkin(at: "path/to/Purple_Glow.wsz")
// Gets you Metal texture + button coordinates + window shape automatically
```

## Button Positioning:
Use the coordinates from button_coordinates.swift to position your play/pause/stop buttons in the correct locations for this skin.

## Window Size:
Set your main window to \(Int(image.size.width))√ó\(Int(image.size.height)) pixels.

## Testing:
1. Copy purple_glow_converted.png to your WinampClone Resources/
2. Update your UI to use the image as background  
3. Position buttons using the provided coordinates
4. Test that buttons align with the visual elements in the skin

This gives you a working Winamp skin on macOS! üéµ
"""

try instructions.write(toFile: outputDir + "/INTEGRATION_INSTRUCTIONS.md", atomically: true, encoding: .utf8)

print("\n‚úÖ Export Complete!")
print("üìÅ Files exported to: \(outputDir)/")
print("   ‚Ä¢ purple_glow_converted.png")
print("   ‚Ä¢ button_coordinates.swift") 
print("   ‚Ä¢ metal_texture_info.txt")
print("   ‚Ä¢ INTEGRATION_INSTRUCTIONS.md")

print("\nüéØ Ready for Manual Integration!")
print("Copy these files to your WinampClone project and follow the instructions.")
print("This will give you a working converted Winamp skin to test with! üéµ")
